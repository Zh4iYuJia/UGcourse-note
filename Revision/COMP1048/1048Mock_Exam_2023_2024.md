# Mock Exam: 2023-2024 Semester 1 (Autumn)

**Module**: COMP1048 Databases and Interfaces
**Time Allowed**: 2 Hours
**Total Marks**: 50

---

## üìä ËÄÉÁÇπÂàÜÂ∏ÉÂàÜÊûê (Exam Analysis)

Ëøô‰ªΩËØïÂç∑ (2023-2024 Autumn) Âª∂Áª≠‰∫ÜÂâç‰∏§Âπ¥ÁöÑÈ£éÊ†ºÔºå‰ΩÜÂú® SQL Êü•ËØ¢ÈöæÂ∫¶‰∏äÊúâÊâÄÊèêÂçáÔºåÁâπÂà´ÊòØÂàÜÁªÑÁªüËÆ°ÂêéÁöÑÁ≠õÈÄâ„ÄÇ

1.  **Web Programming (30%)**:
    *   **Âü∫Á°ÄÊ¶ÇÂøµ**: HTTP ÂçèËÆÆ„ÄÅHTML Â±ûÊÄß (Attributes) ÁöÑÂÆö‰πâ„ÄÇ
    *   **HTML ÁªìÊûÑ**: ÁºñÂÜôÂÆåÊï¥ÁöÑ HTML ÊñáÊ°£ÁªìÊûÑ (DOCTYPE, html, head, body)„ÄÇ
    *   **Flask**: Â§çÊùÇÁöÑË°®ÂçïÈÄªËæëÂ§ÑÁêÜ„ÄÇÈúÄË¶ÅÂêåÊó∂Â§ÑÁêÜ‰∏§‰∏™ËæìÂÖ• (Name, Age) ÁöÑÂ§öÁßçÁªÑÂêàÊÉÖÂÜµÔºå‰ª•ÂèäÊï∞ÊçÆÁ±ªÂûãËΩ¨Êç¢ÂíåÈ™åËØÅ„ÄÇ
2.  **Relational DB Theory (30%)**:
    *   **ÂÖ≥Á≥ª‰ª£Êï∞**: ËÄÉÂØü‰∫Ü œÉ (Ê≥®ÊÑèÈ¢òÁõÆ‰∏≠ÁöÑÂ±ûÊÄßÂêçÈô∑Èò±), œÄ, ‚®ù, ‚à™„ÄÇ
    *   **SQL Êü•ËØ¢**:
        *   `NATURAL JOIN` + `NOT IN` (ÊéíÈô§Ê≥ï)„ÄÇ
        *   **ÈöæÁÇπ**: ÂàÜÁªÑÁªüËÆ°Ê±ÇÊúÄÂ§ßÂÄº (Find the brand with the highest spend for *each* customer)„ÄÇËøôÈÄöÂ∏∏ÈúÄË¶ÅÂ≠êÊü•ËØ¢ÊàñÁ™óÂè£ÂáΩÊï∞„ÄÇ
    *   **‰∫ãÂä° (Transactions)**: ËÄÉÂØüÂÆö‰πâ„ÄÅACID ‰øùËØÅÂíå‰ΩøÁî®Âú∫ÊôØ„ÄÇ
3.  **DB Design (40%)**:
    *   **ER Modelling**: Âú∫ÊôØÊòØ GRP È°πÁõÆÁÆ°ÁêÜ„ÄÇÊ∂âÂèä 1:1 (Topic-Team), 1:N (Team-Student), M:N (Assessment) ÂÖ≥Á≥ª„ÄÇ
    *   **SQL DDL**: Âª∫Ë°®ÂèäÁ∫¶Êùü„ÄÇ
    *   **SQL ÁªüËÆ°**: ËÆ°ÁÆóÂπ≥ÂùáÂàÜÂπ∂Á≠õÈÄâ (`GROUP BY` + `HAVING`)„ÄÇ

---

## üìù Ê®°ÊãüËØïÈ¢ò‰∏éËØ¶Ëß£ (Mock Exam & Solutions)

### Question ONE ‚Äì Web Programming [15 marks]

**a) What is the application layer protocol that powers the world wide web? [1 mark]**

> **ËÄÉÁÇπ**: HTTP ÂçèËÆÆ„ÄÇ
> **Â§ç‰π†Á¨îËÆ∞**: [Section 3.1](Revision.md#31-html-and-css) (See "HTTP")

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

*   **HTTP** (Hypertext Transfer Protocol) or **HTTPS**.
</details>

**b) What are HTML attributes and how are they used? Provide an example. [2 marks]**

> **ËÄÉÁÇπ**: HTML Â±ûÊÄßÂÆö‰πâ„ÄÇ
> **Â§ç‰π†Á¨îËÆ∞**: [Section 3.1](Revision.md#31-html-and-css) (See "HTML")

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

*   **Definition**: Attributes provide additional information about HTML elements. They are always specified in the **start tag**.
*   **Usage**: They usually come in name/value pairs like `name="value"`.
*   **Example**: `<img src="image.jpg" alt="Description">`. Here `src` and `alt` are attributes defining the image source and alternative text.
</details>

**c) Write the full HTML document structure for the webpage "My CS Modules". [5 marks]**

> **ËÄÉÁÇπ**: HTML ÂÆåÊï¥ÁªìÊûÑ (`<!DOCTYPE>`, `<html>`, `<head>`, `<body>`).
> **Â§ç‰π†Á¨îËÆ∞**: [Section 3.1](Revision.md#31-html-and-css) (See "HTML")

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My CS Modules</title>
</head>
<body>
    <h1>My CS Modules</h1>
    <ul>
        <li>Databases and Interfaces</li>
        <li>Programming and Algorithms</li>
        <li>Computer Fundamentals</li>
    </ul>
</body>
</html>
```
</details>

**d) Using Flask, write a function to handle the form (name, age). Validate age >= 18. Handle 4 logic cases. [7 marks]**

> **ËÄÉÁÇπ**: Flask POST, Á±ªÂûãËΩ¨Êç¢, ÈÄªËæëÂàÜÊîØ„ÄÇ
> **Â§ç‰π†Á¨îËÆ∞**: [Section 3.2](Revision.md#32-web-application)

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/process_form', methods=['POST'])
def process_form():
    name = request.form.get('user_name')
    age_str = request.form.get('user_age')
    
    # Case 4: Both empty (Check this first or handle gracefully)
    if not name and not age_str:
        return "How old are you?"

    try:
        age = int(age_str)
    except (ValueError, TypeError):
        # Handle case where age is not a number or is missing
        return "How old are you?" 

    # Case 1: Under 18
    if age < 18:
        return "You must be over 18!"
    
    # Age is >= 18 here
    if name:
        # Case 2: Name not empty, Age >= 18
        return f"Hello {name}"
    else:
        # Case 3: Name empty, Age >= 18
        return "Hello there!"
```
</details>

---

### Question TWO ‚Äì Relational DB Design Theory and DBMS [15 marks]

**Data**:
*   **Customer**: 1(Tom), 2(John), 3(Mike)
*   **Brand**: MSI, ROG, GALAX, GS, COR, KT, HP
*   **Purchase**: (1, ROG, GPU, 18000), (1, PGA?, Mem, 800), ...

**a) Relational Algebra Expressions. [6 marks]**

> **ËÄÉÁÇπ**:  œÉ (Ê≥®ÊÑèÂ±ûÊÄßÂêç), œÄ, ‚®ù, ‚à™.
> **Â§ç‰π†Á¨îËÆ∞**: [Section 2.1](Revision.md#21-relational-model) (See "Relational Algebra")

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

*   **i. œÉ_(cID = 1 AND price > 5000)(Purchase)**
    *   *Note*: The relation schema says `pCost`, but query uses `price`. Assuming `price` refers to `pCost`.
    *   Customer 1 purchases: (ROG, 18000), (PGA, 800), (ROG, 5500).
    *   > 5000: 18000 and 5500.
    *   Result: `{(1, ROG, Graphic Card, 18000), (1, ROG, Monitor, 5500)}`
*   **ii. œÄ_bName (Brand ‚®ù œÉ_(price>2000)(Purchase))**
    *   Purchases > 2000: (1, ROG, 18000), (1, ROG, 5500), (2, MSI, 14500), (3, GALAX, 15000), (3, HP, 3000).
    *   Brands: ROG, MSI, GALAX, HP.
    *   Result: `{(Republic of Gamers), (Micro-Star International), (Galaxy Microsystems), (Hewlett-Packard)}`
*   **iii. Union Query**
    *   Set A (Memory < 500): (2, COR, 350) -> John.
    *   Set B (Graphic Card > 15000): (1, ROG, 18000) -> Tom. (3, GALAX, 15000 is not > 15000, it is =).
    *   Result: `{(John), (Tom)}`
</details>

**b) SQL Output: `SELECT DISTINCT cName ... WHERE cID NOT IN (... 'Monitor')` [2 marks]**

> **ËÄÉÁÇπ**: Exclusion Logic.
> **Â§ç‰π†Á¨îËÆ∞**: [Section 2.3](Revision.md#23-sql-queries) (See "Advanced Querying")

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

*   **Logic**: Find customers who have **NEVER** bought a Monitor.
    *   Who bought Monitor?
        *   (1, ROG, Monitor) -> Tom.
        *   (3, HP, Monitor) -> Mike.
    *   Exclude Tom (1) and Mike (3).
    *   Remaining: John (2).
*   **Output**: `John`
</details>

**c) SQL Query: Customer name, brand code, and total spend for the brand they spent the most money on. [4 marks]**

> **ËÄÉÁÇπ**: Advanced Aggregation (Max of Sum).
> **Â§ç‰π†Á¨îËÆ∞**: [Section 2.3](Revision.md#23-sql-queries) (See "Advanced Querying")

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

This is a challenging query.
```sql
-- Step 1: Calculate total spend per customer per brand
WITH BrandSpend AS (
    SELECT cID, bCode, SUM(pCost) as TotalSpend
    FROM Purchase
    GROUP BY cID, bCode
)
-- Step 2: Select the max spend for each customer
SELECT c.cName, bs.bCode, bs.TotalSpend
FROM Customer c
JOIN BrandSpend bs ON c.cID = bs.cID
WHERE bs.TotalSpend = (
    SELECT MAX(TotalSpend) 
    FROM BrandSpend bs2 
    WHERE bs2.cID = bs.cID
);
```
*Alternative (if Window Functions allowed)*:
```sql
SELECT cName, bCode, TotalSpend
FROM (
    SELECT c.cName, p.bCode, SUM(p.pCost) as TotalSpend,
           RANK() OVER (PARTITION BY c.cID ORDER BY SUM(p.pCost) DESC) as rnk
    FROM Customer c
    JOIN Purchase p ON c.cID = p.cID
    GROUP BY c.cID, p.bCode
)
WHERE rnk = 1;
```
</details>

**d) What is a database transaction? Guarantees? When to use? [3 marks]**

> **ËÄÉÁÇπ**: Transactions, ACID.
> **Â§ç‰π†Á¨îËÆ∞**: [Section 2.4](Revision.md#24-transactions)

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

*   **Definition**: A sequence of database operations treated as a single logical unit of work.
*   **Guarantees**: **ACID** properties (Atomicity, Consistency, Isolation, Durability). Specifically, it guarantees that either all operations succeed or none do (Atomicity).
*   **When to use**: When performing multiple related updates that must remain consistent, e.g., transferring money (debit one, credit another).
</details>

---

### Question THREE ‚Äì SQL and ER Design [20 marks]

**Scenario**: GRP Module.
*   **Teacher**: sID, Name, Gender.
*   **Student**: stID, Name, Gender.
*   **Team**: tID, Name.
*   **Topic**: Title, Description.
*   **Relationships**:
    *   Teacher provides 1 Topic.
    *   Topic allocated to 1 Team. (So Teacher -> Team is 1:1 via Topic).
    *   Team has >= 2 Students (1:N).
    *   Team assessed by 3 Teachers (M:N).

**a) Draw the ERD. [8 marks]**

> **ËÄÉÁÇπ**: ERD Design.
> **Â§ç‰π†Á¨îËÆ∞**: [Section 2.2](Revision.md#22-database-design) (See "ER Diagram")

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°àÊèèËø∞</strong></summary>

*   **Entities**: `Teacher`, `Student`, `Team`, `Topic`.
*   **Relationships**:
    *   `Teacher` **Provides** `Topic` (1:1).
    *   `Topic` **AllocatedTo** `Team` (1:1).
    *   `Team` **Contains** `Student` (1:N).
    *   `Teacher` **Assesses** `Team` (M:N). (Attributes: Score).
</details>

**b) Write SQL DDL. [8 marks]**

> **ËÄÉÁÇπ**: DDL, Constraints.
> **Â§ç‰π†Á¨îËÆ∞**: [Section 2.3](Revision.md#23-sql-queries) (See "DDL")

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

```sql
CREATE TABLE Teacher (
    sID INTEGER PRIMARY KEY,
    Name VARCHAR(100),
    Gender CHAR(1)
);

CREATE TABLE Topic (
    topicID INTEGER PRIMARY KEY,
    Title VARCHAR(200),
    Description TEXT,
    sID INTEGER UNIQUE NOT NULL, -- 1:1 with Teacher
    FOREIGN KEY (sID) REFERENCES Teacher(sID)
);

CREATE TABLE Team (
    tID INTEGER PRIMARY KEY,
    Name VARCHAR(100),
    topicID INTEGER UNIQUE NOT NULL, -- 1:1 with Topic
    FOREIGN KEY (topicID) REFERENCES Topic(topicID)
);

CREATE TABLE Student (
    stID INTEGER PRIMARY KEY,
    Name VARCHAR(100),
    Gender CHAR(1),
    tID INTEGER NOT NULL, -- 1:N with Team
    FOREIGN KEY (tID) REFERENCES Team(tID)
);

-- Assessment (M:N)
CREATE TABLE Assessment (
    sID INTEGER,
    tID INTEGER,
    Score INTEGER,
    PRIMARY KEY (sID, tID),
    FOREIGN KEY (sID) REFERENCES Teacher(sID),
    FOREIGN KEY (tID) REFERENCES Team(tID)
);
```
</details>

**c) SQL: List IDs of students who had an average team score >= 70. [4 marks]**

> **ËÄÉÁÇπ**: Join + Group By + Having.
> **Â§ç‰π†Á¨îËÆ∞**: [Section 2.3](Revision.md#23-sql-queries) (See "Advanced Querying")

<details>
<summary><strong>ÂèÇËÄÉÁ≠îÊ°à</strong></summary>

```sql
SELECT st.stID
FROM Student st
JOIN Team t ON st.tID = t.tID
JOIN Assessment a ON t.tID = a.tID
GROUP BY st.stID, t.tID
HAVING AVG(a.Score) >= 70;
```
*Logic*: Join Student -> Team -> Assessment. Group by Student (and Team). Filter groups where average score >= 70.
</details>
