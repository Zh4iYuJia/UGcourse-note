# Mock Exam: 2022-2023 Semester 1 (Autumn)

**Module**: COMP1048 Databases and Interfaces
**Time Allowed**: 2 Hours
**Total Marks**: 50

---

## ğŸ“Š è€ƒç‚¹åˆ†å¸ƒåˆ†æ (Exam Analysis)

è¿™ä»½è¯•å· (2022-2023 Autumn) ä¸ä¸Šä¸€ä»½ (2021-2022 Spring) ç»“æ„éå¸¸ç›¸ä¼¼ï¼Œä½†åœ¨å…·ä½“è€ƒç‚¹ä¸Šæœ‰æ‰€ä¾§é‡ï¼š

1.  **Web Programming (30%)**:
    *   **åè®®ä¸ DOM**: è€ƒå¯Ÿäº† HTTP åè®®ã€çŠ¶æ€ç ä»¥åŠ DOM çš„æ¸²æŸ“æœºåˆ¶ï¼ˆç†è®ºé¢˜ï¼‰ã€‚
    *   **HTML**: åŸºç¡€ç»“æ„ç¼–å†™ï¼ˆH1, List ç­‰ï¼‰ã€‚
    *   **Flask**: é‡ç‚¹è€ƒå¯Ÿ **POST è¯·æ±‚** çš„å¤„ç† (`request.form`)ï¼Œè¿™ä¸ä¸Šä¸€ä»½è¯•å·çš„ GET è¯·æ±‚å½¢æˆå¯¹æ¯”ã€‚
2.  **Relational DB Theory (30%)**:
    *   **å…³ç³»ä»£æ•°**: ä¾ç„¶æ˜¯é‡ç‚¹ï¼Œè€ƒå¯Ÿäº† Ïƒ, Ï€, â¨, âˆªã€‚
    *   **SQL æŸ¥è¯¢**: è€ƒå¯Ÿäº† `NATURAL JOIN`ï¼Œ`NOT IN` å­æŸ¥è¯¢ï¼Œä»¥åŠèšåˆå‡½æ•° (`AVG`, `MAX`, `MIN`) å’Œåˆ†ç»„ (`GROUP BY`)ã€‚
3.  **DB Design (40%)**:
    *   **ER Modelling**: åœºæ™¯æ˜¯ä¼šè®®ç®¡ç†ç³»ç»Ÿã€‚ç‰¹åˆ«è¦æ±‚**å°†å¤šå¯¹å¤š (M:N) å…³ç³»é™ç»´** (Reduce to 1:N)ï¼Œè¿™æ„å‘³ç€éœ€è¦æ˜¾å¼ç”»å‡ºä¸­é—´å®ä½“ï¼ˆå…³è”è¡¨ï¼‰ã€‚
    *   **SQL DDL**: å»ºè¡¨ï¼Œé‡ç‚¹åœ¨äºå¦‚ä½•è¡¨ç¤ºâ€œè®ºæ–‡-ä½œè€…â€å’Œâ€œè®ºæ–‡-å®¡ç¨¿äººâ€è¿™ä¸¤ä¸ªå¤šå¯¹å¤šå…³ç³»ã€‚
    *   **å¤æ‚æŸ¥è¯¢**: è€ƒå¯Ÿâ€œå…¨ç§°é‡è¯â€é€»è¾‘ï¼ˆä¾‹å¦‚ï¼š*æ‰€æœ‰*å®¡ç¨¿æ„è§éƒ½æ˜¯æ­£é¢çš„ï¼‰ï¼Œé€šå¸¸ç”¨ `NOT EXISTS` æˆ– `NOT IN` (æ’é™¤æ³•) è§£å†³ã€‚

---

## ğŸ“ æ¨¡æ‹Ÿè¯•é¢˜ä¸è¯¦è§£ (Mock Exam & Solutions)

### Question ONE â€“ Web Programming [15 marks]

**a) Name one protocol a web browser and web server can use to communicate with each other. Which response status code(s) might the web server return? [2 marks]**

> **è€ƒç‚¹**: HTTP åè®®, çŠ¶æ€ç ã€‚
> **å¤ä¹ ç¬”è®°**: [Section 3.1](Revision.md#31-html-and-css) (See "HTTP")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ (Click to expand)</strong></summary>

*   **Protocol**: **HTTP** (Hypertext Transfer Protocol) or **HTTPS**.
*   **Status Codes**:
    *   `200 OK`: Request succeeded.
    *   `404 Not Found`: The requested resource could not be found.
    *   `500 Internal Server Error`: The server encountered an error.
    *   *(Any valid HTTP status code is acceptable)*
</details>

**b) What is the Document Object Model (DOM)? How does a web browser use the DOM to render a web page? [2 marks]**

> **è€ƒç‚¹**: DOM å®šä¹‰ä¸æ¸²æŸ“ã€‚
> **å¤ä¹ ç¬”è®°**: [Section 3.1](Revision.md#31-html-and-css) (See "DOM")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ</strong></summary>

*   **DOM**: It is a programming interface for HTML documents. It represents the page so that programs can change the document structure, style, and content. The DOM represents the document as nodes and objects (a tree structure).
*   **How it works**: The browser parses the HTML code to construct the DOM tree. It then uses this tree, combined with CSS (CSSOM), to calculate the layout and paint the content onto the screen (Rendering).
</details>

**c) Write the HTML necessary to represent the following webpage. The text "My Favourite Sports" is a level-1 heading. [4 marks]**
*(Note: The image is missing from the text provided, but usually implies a list structure based on the title)*

> **è€ƒç‚¹**: HTML åŸºç¡€æ ‡ç­¾ (H1, UL/OL).
> **å¤ä¹ ç¬”è®°**: [Section 3.1](Revision.md#31-html-and-css) (See "HTML")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ (å‡è®¾åŒ…å«ä¸€ä¸ªåˆ—è¡¨)</strong></summary>

```html
<!DOCTYPE html>
<html>
<head>
    <title>Sports</title>
</head>
<body>
    <h1>My Favourite Sports</h1>
    <ul>
        <li>Football</li>
        <li>Basketball</li>
        <li>Tennis</li>
    </ul>
</body>
</html>
```
*   *Key Points*: Correct `<h1>` tag. Correct list tags (`<ul>` for unordered or `<ol>` for ordered) and list items `<li>`.
</details>

**d) Using Flask, write a function with correct routing to handle the form below. It should return "Your team's name is: [name]" or an error message. [7 marks]**
```html
<form action="add_new_team" method="post">
<label for="tn"> What is your team's name? </label>
<input type="text" name="team_name" id='tn'>
<input type="submit" value="Submit">
</form>
```

> **è€ƒç‚¹**: Flask Routing, POST Request Handling (`request.form`).
> **å¤ä¹ ç¬”è®°**: [Section 3.2](Revision.md#32-web-application)

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ</strong></summary>

```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/add_new_team', methods=['POST'])
def add_team():
    # Access POST data using request.form
    team_name = request.form.get('team_name')
    
    if team_name:
        return f"Your team's name is: {team_name}"
    else:
        return "You must give a team name!"
```
*   *Key Points*:
    *   Route matches `action="add_new_team"`.
    *   `methods=['POST']` is required.
    *   Use `request.form.get('team_name')` (NOT `request.args`).
    *   Logic to check if `team_name` is empty.
</details>

---

### Question TWO â€“ Relational DB Design Theory and DBMS [15 marks]

**Data for Question:**
*   **Student**: `{(1, Tom), (2, John), (3, Mike)}`
*   **Module**: `{(DBI, ...), (PGA, ...), (MCS, ...)}`
*   **Mark**: `{(1, DBI, 30), (1, PGA, 60), (1, MCS, 80), (2, DBI, 60), (2, MCS, 45), (3, DBI, 71), (3, PGA, 35), (3, MCS, 60)}`

**a) Write down the results of the following relational algebra expressions. [6 marks]**

> **è€ƒç‚¹**: Relational Algebra (Ïƒ, Ï€, â¨, âˆª).
> **å¤ä¹ ç¬”è®°**: [Section 2.1](Revision.md#21-relational-model) (See "Relational Algebra")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ</strong></summary>

*   **i. Ïƒ_(sID = 1 AND mark > 65)(Mark)**
    *   Student 1's marks are 30, 60, 80. Only 80 > 65.
    *   Result: `{(1, MCS, 80)}`
*   **ii. Ï€_mTitle (Module â¨ Ïƒ_(mark<40)(Mark))**
    *   Marks < 40: (1, DBI, 30), (3, PGA, 35).
    *   Join with Module to get titles.
    *   Result: `{(Databases and Interfaces), (Programming and Algorithms)}`
*   **iii. Ï€_sName (...) âˆª Ï€_sName (...)**
    *   Part 1: Students with Mark > 70 in DBI. (3, DBI, 71) -> Mike.
    *   Part 2: Students with Mark > 70 in MCS. (1, MCS, 80) -> Tom.
    *   Union: `{(Mike), (Tom)}`
</details>

**b) List the output of the following SQL query: [2 marks]**
```sql
SELECT sName, mTitle, mCode, mark
FROM Student NATURAL JOIN Mark NATURAL JOIN Module
WHERE sID NOT IN ( SELECT sID FROM Mark WHERE mark < 40)
ORDER BY mark;
```

> **è€ƒç‚¹**: `NATURAL JOIN`, `NOT IN` Subquery.
> **å¤ä¹ ç¬”è®°**: [Section 2.3](Revision.md#23-sql-queries) (See "Advanced Querying")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ</strong></summary>

*   **Logic**:
    *   Subquery: Find sIDs with any mark < 40.
        *   (1, DBI, 30) -> sID 1.
        *   (3, PGA, 35) -> sID 3.
        *   So, exclude sIDs 1 and 3.
    *   Main Query: Only sID 2 (John) remains.
    *   John's marks: (2, DBI, 60), (2, MCS, 45).
    *   Order by mark (ascending).
*   **Output**:
    1.  `John | Mathematics for Computer Scientists | MCS | 45`
    2.  `John | Databases and Interfaces            | DBI | 60`
</details>

**c) Write an SQL query which returns the name, average mark, and range of marks (highest - lowest) for each student. [4 marks]**

> **è€ƒç‚¹**: Aggregation (`AVG`, `MAX`, `MIN`), `GROUP BY`.
> **å¤ä¹ ç¬”è®°**: [Section 2.3](Revision.md#23-sql-queries) (See "Advanced Querying")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ</strong></summary>

```sql
SELECT 
    s.sName, 
    AVG(m.mark) AS AverageMark, 
    (MAX(m.mark) - MIN(m.mark)) AS MarkRange
FROM Student s
JOIN Mark m ON s.sID = m.sID
GROUP BY s.sID, s.sName;
```
</details>

**d) Advantages of utilising a DBMS? [3 marks]**

> **è€ƒç‚¹**: DBMS Advantages.
> **å¤ä¹ ç¬”è®°**: [Section 2.1](Revision.md#21-relational-model) (See "What is DBMS?")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ</strong></summary>

*   (Same as previous year)
*   Data Independence, Data Integrity, Concurrency Control, Crash Recovery, Security.
</details>

---

### Question THREE â€“ SQL and ER Design [20 marks]

**Scenario**: Conference System.
*   **Participants**: Name, Email, ID. (Can be Author or Reviewer).
*   **Papers**: Title, pID.
*   **Submission**: Author submits Paper (M:N).
*   **Review**: Reviewer reviews Paper (M:N). Review has `Recommendation` (Pos/Neg).
*   **Constraint**: Reviewer cannot review own paper.

**a) Draw the ERD. Reduce all Many to Many relationships to 1 to Many. [8 marks]**

> **è€ƒç‚¹**: ERD, M:N Decomposition (Associative Entities).
> **å¤ä¹ ç¬”è®°**: [Section 2.2](Revision.md#22-database-design) (See "ER Diagram")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆæè¿°</strong></summary>

*   **Entities**:
    *   `Participant` (ID, Name, Email)
    *   `Paper` (pID, Title)
    *   `Authorship` (Associative Entity between Participant and Paper)
    *   `Review` (Associative Entity between Participant and Paper, with attribute `Recommendation`)
*   **Relationships (Reduced)**:
    *   `Participant` **1 ---- N** `Authorship`
    *   `Paper` **1 ---- N** `Authorship`
    *   `Participant` **1 ---- N** `Review`
    *   `Paper` **1 ---- N** `Review`
</details>

**b) Write the necessary SQL code (DDL). [8 marks]**

> **è€ƒç‚¹**: SQL DDL, Foreign Keys for M:N.
> **å¤ä¹ ç¬”è®°**: [Section 2.3](Revision.md#23-sql-queries) (See "DDL")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ</strong></summary>

```sql
CREATE TABLE Participant (
    uID INTEGER PRIMARY KEY,
    Name VARCHAR(100),
    Email VARCHAR(100) UNIQUE
);

CREATE TABLE Paper (
    pID INTEGER PRIMARY KEY,
    Title VARCHAR(200)
);

-- Authorship (M:N decomposition)
CREATE TABLE Authorship (
    uID INTEGER,
    pID INTEGER,
    PRIMARY KEY (uID, pID),
    FOREIGN KEY (uID) REFERENCES Participant(uID),
    FOREIGN KEY (pID) REFERENCES Paper(pID)
);

-- Review (M:N decomposition)
CREATE TABLE Review (
    uID INTEGER, -- Reviewer ID
    pID INTEGER,
    Recommendation VARCHAR(10) CHECK (Recommendation IN ('Positive', 'Negative')),
    PRIMARY KEY (uID, pID),
    FOREIGN KEY (uID) REFERENCES Participant(uID),
    FOREIGN KEY (pID) REFERENCES Paper(pID)
);
```
</details>

**c) Write SQL to list all IDs of papers that are accepted (all reviews are positive). [4 marks]**

> **è€ƒç‚¹**: "For All" Logic / Exclusion Logic.
> **å¤ä¹ ç¬”è®°**: [Section 2.3](Revision.md#23-sql-queries) (See "Advanced Querying")

<details>
<summary><strong>å‚è€ƒç­”æ¡ˆ</strong></summary>

*   **Method 1: Exclusion (Recommended)**
    *   Find papers that have at least one negative review, and exclude them.
    ```sql
    SELECT pID FROM Paper
    WHERE pID NOT IN (
        SELECT pID FROM Review WHERE Recommendation = 'Negative'
    );
    ```
*   **Method 2: Aggregation**
    *   Group by paper and check if the minimum recommendation is Positive (assuming no other values).
    ```sql
    SELECT pID 
    FROM Review
    GROUP BY pID
    HAVING MIN(Recommendation) = 'Positive'; 
    -- Note: This assumes 'Positive' and 'Negative' are the only values. 
    -- If 'Negative' < 'Positive' alphabetically, MIN='Positive' implies no 'Negative'.
    ```
</details>
