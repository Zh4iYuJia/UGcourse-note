# 2022-2023 期末真题详细解析 (Exam Analysis)

> **注意**: 本文档按照你提供的 22/23 年真题截图编写。所有的数学公式和逻辑符号均已转换为纯文本格式，方便阅读。

---

## 为了高分，你需要做对哪些题？
这份试卷总分 **50分**。
*   **基础分 (拿到这 30 分就及格)**: 二进制转换、真值表、翻译流程图、简单的汇编结果预测。
*   **进阶分 (拿到这 15 分冲优)**: 布尔代数化简、VM 代码的逻辑理解、Fetch-Execute 循环描述。
*   **难点分 (最后 5 分)**: 手写 VM 到 Hack 汇编的底层实现代码 (Q2e)。

---

## Question 1: Logic & Hardware (25 分)

### (a) 二进制转换 (Binary Conversion) [3分]
将 8位补码 (Two's Complement) 转为十进制。

1.  **`a = 1011 0011`**
    *   **判断**: 最高位是 1，所以是**负数**。
    *   **计算**: 先取反 `0100 1100`，再加 1 得到 `0100 1101`。
    *   转换: `1001101` = 64 + 8 + 4 + 1 = 77。
    *   **结果**: **-77**

2.  **`b = 0110 0011`**
    *   **判断**: 最高位是 0，所以是**正数**。
    *   **计算**: 直接转。64 + 32 + 2 + 1 = 99。
    *   **结果**: **99**

3.  **`c = 1111 0000`**
    *   **判断**: 最高位是 1，负数。
    *   **计算**: 取反 `0000 1111`，加 1 得到 `0001 0000` (16)。
    *   **结果**: **-16**

### (b) 十进制转二进制 (Decimal to Binary) [3分]
将十进制转为 8位补码。

1.  **`a = -123`**
    *   正数 123 = 64 + 32 + 16 + 8 + 2 + 1 = `0111 1011`
    *   取反: `1000 0100`
    *   加 1: `1000 0101`
    *   **答案**: **1000 0101**

2.  **`b = -79`**
    *   正数 79 = 64 + 8 + 4 + 2 + 1 = `0100 1111`
    *   取反: `1011 0000`
    *   加 1: `1011 0001`
    *   **答案**: **1011 0001**

3.  **`c = 41`**
    *   直接转: 32 + 8 + 1 = `0010 1001`
    *   **答案**: **0010 1001**

### (c) 布尔表达式化简 (Boolean Simplify) [6分]
技巧：消去律 `X + X'Y = X + Y` 和 吸收律 `X + XY = X`。

1.  **`(i) C(CB + A'B) + B'A`** (修正了题目里的横线范围)
    *   展开括号: `CCB + CA'B`
    *   由 `CC = C` 得: `CB + CA'B`
    *   提取公因式 `CB(1 + A')`? 不对，应该这样看:
    *   `CB` 和 `CA'B` 里都有 B。
    *   这题如果后面是 `B'A`，那其实前面化简完是 `CB(1+A')` -> `CB`。
    *   最后: **`CB + AB'`** (无法进一步化简，除非题目抄错)

2.  **`(ii) (CD + C'B)C + B'B`**
    *   **第一步**: 看到 **`B'B`** 直接划掉，等于 **0**。
    *   **第二步**: 把外面的 C 乘进去 -> `CDC + C'BC`。
    *   **第三步**:
        *   `CDC` -> `CD` (因为 CC=C)
        *   `C'BC` -> `0` (因为 C' 与 C 冲突，C'C=0)
    *   **答案**: **`CD`**

3.  **`(iii) C(BD + B(BD)) + CC'`**
    *   **第一步**: 看到 **`CC'`** 直接划掉，等于 **0**。
    *   **第二步**: 看括号里 `B(BD)` -> `BBD` -> `BD`。
    *   **第三步**: 括号里变成了 `BD + BD` -> `BD`。
    *   **第四步**: 外面还有个 C，乘进去。
    *   **答案**: **`CBD`** (或 BCD)

### (d) 真值表填空 (Truth Table) [8分]
电路逻辑分析：
*   上面那个 `AND` 门的输入是: `NOT(C)` 和 `A`。也就是 **`E = A AND NOT(C)`**。
*   下面那个 `AND` 门的输入是: `NOT(D)` 和 `B`。也就是 **`F = B AND NOT(D)`**。
*   最后的 `OR` 门: **`Z = E OR F`**。

题目给的表头只有 A, B, C, D，但下面的行只列了 A, B 的 00, 01, 10, 11。这可能意味着 C和D 是内部连接或者省略了？
*(注意：看图，C接在了A线上，D接在了B线上吗？图有点小。通常如果是 4 输入，会有 16 行。如果 C接A，D接B，那么逻辑就是: 上路=A AND NOT(A)=0, 下路=B AND NOT(B)=0。这不可能。)*
*   **修正看图**: 图上的线，C 好像是接在这个模块的输入引脚上，但被上面的非门反转了。如果 C 和 D 只是标签，那我们需要看它们连哪里。 **仔细看线**:
    *   上路非门的输入连在 A 上 -> 所以上面的输入其实是 `NOT(A)`。
    *   下路非门的输入连在 B 上 -> 所以下面的输入其实是 `NOT(B)`。
    *   **更正后的逻辑**:
        *   上路 AND: 输入是 `NOT(A)` 和 `...`? 不，看线。
        *   让我们假设这是一个标准的 **XOR 实现架构**?
            *   上路: `A` (直连) 和 `NOT(B)`。 -> `A AND B'`
            *   下路: `B` (直连) 和 `NOT(A)`。 -> `B AND A'`
            *   最后 OR: `AB' + A'B`。
            *   **这就是 XOR (异或) 门！**

    *   **如果这是 XOR 门，真值表答案**:
        *   0, 0 -> 0
        *   0, 1 -> 1
        *   1, 0 -> 1
        *   1, 1 -> 0

### (e) Fetch-Execute Cycle [5分]
写出处理器取指执行循环的伪代码。

```text
Loop {
    // 1. Fetch (取指令)
    Instruction = RAM[PC]
    
    // 2. Decode (译码)
    if (Instruction 是 A指令) {
        ...处理地址...
    } else {
        ...处理计算与跳转...
    }
    
    // 3. Execute (执行)
    执行 ALU 计算
    将结果写回 寄存器 或 内存
    
    // 4. Update PC (更新计数器)
    if (Jump 条件满足) {
        PC = 跳转地址
    } else {
        PC = PC + 1
    }
}
```

---

## Question 2: Software Hierarchy (25 分)

### (a) 汇编追踪 (Trace) [6分]
代码逻辑翻译：
```asm
i = 2
s = 0
(LOOP)
  if (i > 3) goto END  // D = i - 3; D;JGT
  s = s + i            // s = s + i
  i = i + 1            // i++
  goto LOOP
(END)
```

1.  **i=2**: 不满足 >3。s = 0+2=2。i 变成 3。
2.  **i=3**: 不满足 >3 (因为是 > 不是 >=)。s = 2+3=5。i 变成 4。
3.  **i=4**: 满足 4 > 3。跳转 END。

**(i) 结果**: `RAM[17]` (也就是变量 s) 的值是 **5**。

**(ii) 机器码**:
*   `@END` -> 假设 END 是第 18 行。机器码: `0000000000010010` (18的二进制)。
*   `0;JMP` -> `111` (C指令头) `0101010` (comp=0) `000` (dest=null) `111` (jump=JMP)。
    *   答案: **`1110101010000111`**

### (c) VM 代码堆栈追踪 [6分]
代码逻辑:
```text
sum = 0
count = y (argument 1)
LOOP:
  if (count == 0) goto END
  sum = sum + x (argument 0)
  count = count - 1
  goto LOOP
```
这是一个**乘法**算法 (加 x, 重复 y 次)。

**(i) 堆栈状态**:
*   Argument 0 (x) = 3
*   Argument 1 (y) = 4
*   循环执行 4 次 `sum + 3`。
*   最终结果: **12**。这个结果会保存在 `local 0` 中。

**(ii) 功能**:
*   它执行的是 **乘法操作 (Multiplication)**。
*   结果存储在 **`local 0`** 内存段中。

### (d) 复杂逻辑翻译 (Logic Translation) [5分]
**`z = (x > 7) and (x + y < 30)`**

按顺序把操作数压栈，然后调用运算指令。
1.  `push x`
2.  `push constant 7`
3.  **`gt`** (比较 x>7)
4.  `push x`
5.  `push y`
6.  **`add`** (算 x+y)
7.  `push constant 30`
8.  **`lt`** (比较 x+y < 30)
9.  **`and`** (把两个比较结果逻辑与)
10. `pop z`

### (e) VM 翻译实现 (VM Implementation) - **难点** [5分]
将 **`push local 5`** 翻译成 Hack 汇编。

这是考你 Stack Mapping 的底层原理。
你需要：拿到 (LCL基址 + 5) 的数据，放到 *SP，然后 SP++。

**标准答案**:
```asm
// 1. 计算目标地址 addr = LCL + 5
@5
D=A      // D = 5
@LCL
A=M+D    // A = RAM[LCL] + 5 (这就指向了 local 5)
D=M      // D = RAM[addr] (取出了值)

// 2. 将值压入栈顶 *SP = D
@SP
A=M      // A = SP (指向栈顶空位)
M=D      // 写入数据

// 3. 栈指针自增 SP++
@SP
M=M+1
```
