# COMP1036/AE1CSF-E1 试卷分析与解析

这份2023-2024年的考卷总分50分，分两个大题（Part 1 和 Part 2），考查了这门课两个主要模块的基础知识。

## Part 1: 数据表示与逻辑硬件 (Question 1 - 25分)

**核心考查点**：2的补码 (Two's Complement)、布尔代数简化、时序逻辑电路 (Sequential Logic)、PC 工作原理。

### (a) 8位补码转十进制 (3分)
**考点**：2的补码转换规则。
*   如果最高位是0：正数，直接按权展开。
*   如果最高位是1：负数，先按位取反，再加1，得到正数值，最后加上负号。

**解析**：
*   **a = 1110 1011**：首位是1（负数）。
    *   取反: `0001 0100` -> 20
    *   加1: 20 + 1 = 21
    *   结果: **-21**
*   **b = 1110 0011**：首位是1（负数）。
    *   取反: `0001 1100` -> 28
    *   加1: 28 + 1 = 29
    *   结果: **-29**
*   **c = 0111 0001**：首位是0（正数）。
    *   直接计算: 64 + 32 + 16 + 1 = **113**

### (b) 十进制转8位补码 (3分)
**考点**：十进制转二进制补码。
*   正数：直接转换。
*   负数：写出对应正数的二进制，按位取反，再加1。

**解析**：
*   **a = -117**
    *   +117 二进制: `0111 0101` (64+32+16+4+1)
    *   取反: `1000 1010`
    *   加1: **`1000 1011`**
*   **b = -12**
    *   +12 二进制: `0000 1100`
    *   取反: `1111 0011`
    *   加1: **`1111 0100`**
*   **c = 49** (正数)
    *   直接转换: 32 + 16 + 1 = **`0011 0001`**

### (c) 布尔表达式简化 (6分)
**考点**：布尔代数法则 (分配律, 消去律, X AND NOT(X) = 0, X + NOT(X) = 1, X AND 1 = X, A + AB = A)。

**解析**：
**(i) B + (D(AD + CB) + AD)C**
1.  展开内部括号: B + (DAD + DCB + AD)C (注: D AND D = D)
2.  整理: B + (AD + BCD + AD)C
3.  合并AD: B + (AD + BCD)C
4.  展开C: B + ADC + BCDC (注: C AND C = C)
5.  整理: B + ACD + BCD
6.  提取B: B(1 + CD) + ACD (注: 1 + X = 1)
7.  结果: **B + ACD**

**(ii) NOT(B)A + (CB + B NOT(C))C**
1.  展开C: NOT(B)A + CBC + B NOT(C)C
2.  消去项: B NOT(C)C = 0
3.  整理: NOT(B)A + BC (注: C AND C = C)
4.  结果: **NOT(B)A + BC** (或者写成 A NOT(B) + BC)

**(iii) C NOT(D) + (DA + C NOT(C))B**
1.  消去项: C NOT(C) = 0
2.  括号内结果: DA + 0 = DA
3.  整理: **C NOT(D) + DAB**

### (d) 画图: 1-bit Register (5分)
**考点**：理解 Register 由 DFF 和 Mux 组成。
**解析**：这是一个经典的电路图。
*   核心组件: **DFF** (Data Flip Flop) 和 **Mux** (Multiplexer)。
*   输入: `in`, `load`。
*   输出: `out`。
*   逻辑: DFF 的输出反馈回 Mux 的 0号输入端；`in` 连接 Mux 的 1号输入端；`load` 作为 Mux 的选择位 (sel)；Mux 的输出连接 DFF 的输入。
*   *(由于无法画图，请参考 PPT 中 Register 的设计图，重点在于反馈回路 Load bit 控制 Mux)*

### (e) Program Counter (PC) 的工作步骤 (8分)
**考点**：PC 的核心功能逻辑 (Reset, Jump, Increment)。
**解析**：Hack 计算机的 PC 逻辑如下：
1.  **Reset**: 如果 `reset` 信号为 1，PC 设置为 0 (重启程序)。
2.  **Jump** (Load): 如果没有 Reset，但 jump 条件满足 (load=1)，PC 设置为 A 寄存器的值 (`in`)。
3.  **Increment**: 如果上述都没有发生 (inc=1)，PC 加 1 (执行下一条指令)。
4.  **Maintain**: 在某些特定周期下保持不变 (不过在 Hack 简化模型中通常总是 Inc 或 Load)。
*(注：官方课件通常描述为 if(reset) PC=0; else if(load) PC=in; else if(inc) PC++; else PC=PC)*

---

## Part 2: 体系结构与 VM (Question 2 - 25分)

**核心考查点**：Hack 汇编追踪、机器码转换、寻址模式、VM 堆栈模拟、VM 转汇编。

### (a) 汇编代码分析 (6分)
**考点**：追踪汇编代码执行流程 (Trace)。
**代码逻辑**：
1.  `RAM[0]=1`, `RAM[1]=2`, `RAM[2]=0`.
2.  检查 `RAM[0]` 和 `RAM[1]` 是否为 0，如果是则跳转 END。
3.  `RAM[3] = RAM[0]` (值为 1)。
4.  `LOOP`:
    *   `D = RAM[1]` (2)
    *   `RAM[2] = D + RAM[2]` (2 + 0 = 2)
    *   `RAM[3] = RAM[3] - 1` (1 - 1 = 0)
    *   `D = RAM[3]` (0)
    *   `D;JGT`: 0 不大于 0，**不跳转**。
5.  `END`: 无限循环。

**(i) RAM[2] 的值**
**解析**:
循环只执行了一次。
RAM[2] 初始为 0。加上 RAM[1] (2) 后变为 2。
结果：**2**

**(ii) 机器码转换**
**考点**: A-Instruction 和 C-Instruction 格式。
*   `@0` -> `@value` -> `0vvv vvvv vvvv vvvv`
    *   `@0` -> **`0000 0000 0000 0000`**
*   `M=1` -> `dest=comp` -> `111 a cccccc ddd jjj`
    *   comp = 1 -> `0 111111` (查表)
    *   dest = M -> `001`
    *   jump = null -> `000`
    *   结果: **`1110 1111 1100 1000`**

### (b) 寻址模式定义 (3分)
**解析**：
(i) **Immediate**: 操作数直接包含在指令中 (例如 `push constant 5`)。
(ii) **Direct**: 指令包含操作数的内存地址 (例如 `pop static 5`，直接访问 `@16`)。
(iii) **Indirect**: 指令包含一个指向操作数地址的指针 (例如 `pop local 0`，需要先读 `LCL` 的值作为地址)。

### (c) VM 堆栈模拟 (4分)
**考点**: 基础 VM 指令 (eq, lt, gt, add, sub, neg, and, or, not)。
这是一道典型的堆栈跟踪题。
1.  7==7 (True/-1) -> Stack: `[-1]`
2.  2<1 (False/0) -> Stack: `[-1, 0]`
3.  7>6 (True/-1) -> Stack: `[-1, 0, -1]`
4.  压入 57, 31, 53 -> Stack: `[-1, 0, -1, 57, 31, 53]`
5.  `add` (31+53=84) -> Stack: `[-1, 0, -1, 57, 84]`
6.  `push 112`, `sub` (84-112=-28) -> Stack: `[-1, 0, -1, 57, -28]`
7.  `neg` (28) -> Stack: `[-1, 0, -1, 57, 28]`
8.  `and` (57&28 = 24) -> Stack: `[-1, 0, -1, 24]` (注: `111001 & 011100 = 011000`)
9.  `push 82`, `or` (24|82 = 90) -> Stack: `[-1, 0, -1, 90]` (注: `00011000 | 01010010 = ...`)
    *   *勘误: 题目图片是 push 8，但这里解析假设为 push 82。如果是 push 8, 24|8=24。*
    *   *按照原题截图*: `and` 结果 24。`push 8`。`or` (24|8 = 24)。`not` (~24 = -25)。
    *   如果按照你之前提供的 Log (and 结果为 24, push 8, or 得到 24, not 得到 -25)。
    *   前面的布尔值一直保留在栈底。
    
**最终堆栈 (从底到顶)**:
**-1, 0, -1, -25**

### (d) 表达式转 VM (2分)
**考点**: 后缀表达式。
`d = (2 - x) + (y + 9)`
**解析**:
```vm
push constant 2
push static 0   // 假设 x 是 static 0
sub
push static 1   // 假设 y 是 static 1
push constant 9
add
add
pop static 2    // 假设 d 是 static 2
```

### (e) 堆栈与内存状态图 (5分)
**考点**: 画出 `(x > 7) and (y > 7)` 的过程。
需画出 SP 的移动和栈内数值。
1. `push x`, `push 7`, `gt` -> 栈顶变为 True/False。
2. `push y`, `push 7`, `gt` -> 栈顶变为 True/False。
3. `and` -> 计算结果。

### (f) Translate "push local 5" (5分)
**考点**: VM 转汇编 (Part 1 必考题)。
**解析**:
```asm
@5          // i = 5
D=A
@LCL        // 获取 LCL 基址
A=D+M       // A = LCL + 5 (直接指向目标地址)
D=M         // D = RAM[LCL + 5] (取出每一个值)
@SP
A=M         // 指向栈顶
M=D         // *SP = D (压入值)
@SP
M=M+1       // SP++
```
(如果是 `pop local 5` 则更复杂，需要临时变量，但这道题是 `push`，相对简单)。
