# COMP1038 期末复习重点笔记

这份笔记整理了你所有的提问、模拟题中的核心考点以及详细的解析。

---

## 第一部分：考点频率统计 (Concept Frequency Analysis)

根据历年真题和你的提问，以下是出现频率最高的考点，请**优先复习**：

| 考点 | 出现频率 | 涉及题目/年份 | 核心关键词 |
| :--- | :---: | :--- | :--- |
| **指针基础与运算** | ⭐⭐⭐⭐⭐ | Q8, 2022 Q3, 2021 Q1 | `*p`, `&a`, `*p++`, 指针步长 |
| **动态内存分配** | ⭐⭐⭐⭐⭐ | Q7, 2020 Q2, 2021 Q2 | `malloc`, `free`, 内存泄漏, 栈vs堆 |
| **结构体与指针** | ⭐⭐⭐⭐ | Q5, Q6, 2022 Q4 | `struct`, `->`, `typedef`, 结构体比较 |
| **函数参数传递** | ⭐⭐⭐⭐ | Q8, 2020 Q1, 2022 Q5 | Call by Value vs Reference, 二级指针 |
| **字符串处理** | ⭐⭐⭐ | Q5, Q6, 2021 Q1 | `strcmp`, 字符串字面量, `\0` |
| **输入输出陷阱** | ⭐⭐⭐ | Q5, Q6, 2022 Q2 | `scanf` 缓冲区, `\n`, 文件指针 |

---

## 第二部分：精选真题与详细解析 (Selected Questions & Analysis)

### [Question 8] 指针运算与参数传递 (综合大题)
**题目**: 分析 `f1` (值传递), `f2` (混合), `f3` (指针), `f4` (指针重定向) 的输出结果。
**考点**:
1.  **值传递 vs 地址传递**: `f1(k, m)` 修改的是副本，不影响 `main`。`f3(&k, &m)` 修改的是原值。
2.  **指针重定向陷阱**: 在 `f4` 中，`z = &x` 改变了局部指针 `z` 的指向，导致后续的 `*z = ...` 修改的是局部变量 `x`，而不是外部变量 `r`。
3.  **指针解引用**: `*x = *x + 2` 是修改值。

### [Question 5 & 6] 结构体纠错 (Identify Mistakes)
**题目**: 找出代码中的 5 个错误 (结构体定义、scanf、比较、函数声明)。
**考点**:
1.  **字符串比较**: 不能用 `==`，必须用 `strcmp(s1, s2)` (需 `<string.h>`)。
2.  **`scanf` 地址符**: 读取整数必须加 `&` (`scanf("%d", &age)`), 读取字符串不需要 (`scanf("%s", name)`).
3.  **函数原型**: 函数使用前必须声明或定义。
4.  **结构体比较**: 不能直接用 `==` 比较两个结构体，必须逐个成员比较。
5.  **返回类型**: 函数必须显式声明返回类型 (如 `int`)。

### [Question 7] 结构体内存泄漏 (Memory Leak)
**题目**: `struct ex *p = malloc(...); p->s = malloc(...); free(p);`
**考点**:
1.  **释放顺序**: 先释放成员指向的内存 (`free(p->s)`), 再释放结构体本身 (`free(p)`).
2.  **内存泄漏**: 如果先 `free(p)`，就找不到 `p->s` 了，导致那块内存永远无法回收。

### [2022 Q3] `const` 指针辨析
**考点**:
*   `const int *p`: **指向常量的指针**。不能改值 (`*p=5` ❌)，能改指向 (`p=&b` ✅)。
*   `int * const p`: **常量指针**。不能改指向 (`p=&b` ❌)，能改值 (`*p=5` ✅)。

### [2020 Q2 / 2021 Q2] 动态内存分配
**考点**:
*   **Malloc**: `int *arr = (int*)malloc(1000 * sizeof(int));`
*   **检查**: `if (arr != NULL) ...`
*   **释放**: `free(arr);`
*   **栈 vs 堆**: 大数组必须用 `malloc` (堆)，否则栈溢出。

### [Question 8] 结构体综合纠错 (Identify Mistakes)
**题目**: 找出 `func` 函数中的错误 (`scanf`, `printf`, `free`).
**代码片段**:
```c
struct ex *p = malloc(sizeof(struct ex));
p->s = malloc(20);
scanf("%s", &p->s); // 错误1
printf("%s", p->s)  // 错误2
free(p);            // 错误3
```
**解析**:
1.  **`scanf` 错误**: `p->s` 已经是地址，不应加 `&`。修正: `scanf("%s", p->s);`
2.  **语法错误**: `printf` 缺分号。
3.  **内存泄漏**: 先 `free(p)` 会导致 `p->s` 指向的内存无法释放。必须先 `free(p->s)`。

### [Question 7] 链表遍历 (Linked List Traversal)
**题目**: 补全 `printList` 函数，打印链表所有值。
**代码**:
```c
void printList() {
    Node *current = head; // 关键：不要直接移动 head
    while (current != NULL) {
        printf("%d\n", current->data);
        current = current->next;
    }
}
```
**考点**: 必须使用临时指针遍历，防止丢失头节点。

### [Question 5] 链表结构体定义 (Linked List Definition)
**题目**: 定义 `Student_list` 包含 ID, name, marks.
**代码**:
```c
struct Student_list {
    int ID;
    char student_name[50];   // 必须是数组，不能是 char*
    float module_marks[8];
    struct Student_list *next; // 必须包含指向自身的指针
};
```

---

## 第三部分：核心知识点手册 (Core Concepts Handbook)

### 1. 指针进阶 (Advanced Pointers)

#### 1.1 `*p++` 的含义
*   **优先级**: `++` (后置) 高于 `*`。
*   **步骤**:
    1.  先取 `p` 的旧地址备用。
    2.  `p` 自增 (移到下一个元素)。
    3.  对旧地址解引用。
*   **结果**: 取出当前值，指针移到下一位。

#### 1.2 二级指针 (Pointer to Pointer)
*   **定义**: `int **pp;` (指向指针的指针)。
*   **用途**: 当需要在函数内部**修改指针本身** (让它指向别处) 时使用。
    *   *例子*: `void allocate(int **pp) { *pp = malloc(...); }`
*   **对比**:
    *   修改值 -> 传一级指针 `int *`。
    *   修改指针 -> 传二级指针 `int **`。

#### 1.3 指针步长 (Pointer Arithmetic)
*   `p + 1` 增加的字节数等于 `sizeof(类型)`。
    *   `char *`: +1 字节。
    *   `int *`: +4 字节。

### 2. 结构体 (Structures)

#### 2.1 `typedef` 别名
*   `typedef struct Student Stu;` -> 以后可以用 `Stu s;` 代替 `struct Student s;`。

#### 2.2 箭头运算符 `->`
*   **场景**: 当你有一个结构体**指针**时使用。
*   **等价**: `p->age` 等价于 `(*p).age`。

### 3. 函数与参数 (Functions)

#### 3.1 返回值 vs 指针参数
*   **返回值**: 适合单一结果，简单直观。
*   **指针参数**: 适合返回多个结果 (如商和余数)，或处理大结构体 (避免复制，提高效率)。

#### 3.2 Call by Reference (模拟)
*   C 语言只有 Call by Value。
*   通过传递指针 (地址)，我们**模拟**了 Call by Reference，允许函数修改外部变量。

### 4. 输入输出 (I/O)

#### 4.1 `scanf` 缓冲区陷阱
*   **问题**: `scanf("%d", &n)` 后会留下一个换行符 `\n`。
*   **后果**: 下一个 `scanf("%c", &c)` 会直接读取这个 `\n` 而不等待输入。
*   **解决**: `scanf(" %c", ...)` (加空格) 或 `getchar()` 吃掉换行符。

---

## 第四部分：其他基础知识 (Reference)

### 1. 文件指针 (2022 Q2)
*   **解释**: 文件指针是一个指向 `FILE` 结构的指针，用于在 C 语言中处理文件流（读取/写入）。它保存了文件的当前位置、读写状态等信息。
*   **声明**: `FILE *fp;`

### 2. 段错误 (Segmentation Fault) (2021 Q1)
*   **解释**: 这是一个运行时错误 (Run-time error)，通常发生在程序试图访问**未被允许访问的内存区域**时。
*   **常见原因**:
    1.  解引用空指针 (`NULL` pointer dereference)。
    2.  访问数组越界 (Array out of bounds)。
    3.  试图修改只读内存 (如修改字符串字面量)。
    4.  使用未初始化的指针 (Dangling pointer / Wild pointer)。

### 3. 循环转换 (2021 Q4)
将 `for` 循环转换为 `while` 循环。
*   **原代码**:
    ```c
    for(a=1; a<=100; a++)
        printf("%d\n", a*a);
    ```
*   **转换后**:
    ```c
    a = 1; // 初始化
    while(a <= 100) { // 条件
        printf("%d\n", a*a);
        a++; // 迭代
    }
    ```

---
**祝你期末考试取得优异成绩！ Good Luck!**
